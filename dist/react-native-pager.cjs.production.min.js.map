{"version":3,"file":"react-native-pager.cjs.production.min.js","sources":["../src/pager.tsx","../src/util.ts","../src/pagination.tsx"],"sourcesContent":["import React, {\n  useState,\n  Children,\n  createContext,\n  useContext,\n  useEffect,\n} from 'react';\nimport { StyleSheet, LayoutChangeEvent, ViewStyle } from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport {\n  PanGestureHandler,\n  State,\n  PanGestureHandlerProperties,\n} from 'react-native-gesture-handler';\n\nexport type SpringConfig = {\n  damping: Animated.Adaptable<number>;\n  mass: Animated.Adaptable<number>;\n  stiffness: Animated.Adaptable<number>;\n  overshootClamping: Animated.Adaptable<number> | boolean;\n  restSpeedThreshold: Animated.Adaptable<number>;\n  restDisplacementThreshold: Animated.Adaptable<number>;\n  toValue: Animated.Adaptable<number>;\n};\n\n// copied from react-native-reanimated for now, can't get the export\nexport enum Extrapolate {\n  EXTEND = 'extend',\n  CLAMP = 'clamp',\n  IDENTITY = 'identity',\n}\n\ninterface InterpolationConfig {\n  inputRange: ReadonlyArray<Animated.Adaptable<number>>;\n  outputRange: ReadonlyArray<Animated.Adaptable<number>>;\n  extrapolate?: Extrapolate;\n  extrapolateLeft?: Extrapolate;\n  extrapolateRight?: Extrapolate;\n}\n\ntype iInterpolationFn = (\n  offset: Animated.Node<number>\n) => Animated.Node<number>;\n\ninterface iInterpolationConfig extends InterpolationConfig {\n  unit?: string;\n}\n\ntype iTransformProp = {\n  [transformProp: string]: iInterpolationConfig | iInterpolationFn;\n};\n\nexport interface iPageInterpolation {\n  [animatedProp: string]:\n    | iTransformProp[]\n    | iInterpolationConfig\n    | iInterpolationFn;\n}\n\nconst VERTICAL = 1;\nconst HORIZONTAL = 2;\nconst UNSET = -1;\nconst TRUE = 1;\nconst FALSE = 0;\n\nconst {\n  // @ts-ignore\n  event,\n  defined,\n  block,\n  Value,\n  divide,\n  cond,\n  eq,\n  add,\n  stopClock,\n  Clock,\n  set,\n  clockRunning,\n  multiply,\n  sub,\n  call,\n  max,\n  min,\n  greaterThan,\n  abs,\n  ceil,\n  interpolate,\n  concat,\n  neq,\n  and,\n  startClock,\n  spring,\n  // @ts-ignore\n  debug,\n} = Animated;\n\nexport interface iPager {\n  onChange?: (nextIndex: number) => void;\n  initialIndex?: number;\n  children: React.ReactNode[];\n  springConfig?: Partial<SpringConfig>;\n  pageInterpolation?: iPageInterpolation;\n  panProps?: Partial<PanGestureHandlerProperties>;\n  pageSize?: number;\n  threshold?: number;\n  minIndex?: number;\n  maxIndex?: number;\n  adjacentChildOffset?: number;\n  style?: ViewStyle;\n  containerStyle?: ViewStyle;\n  type?: 'horizontal' | 'vertical';\n  clamp?: {\n    prev?: number;\n    next?: number;\n  };\n  clampDrag?: {\n    prev?: number;\n    next?: number;\n  };\n}\nconst REALLY_BIG_NUMBER = 1000000000;\n\n// at its core, this component converts an activeIndex integer value to an Animated.Value\n// this animated value represents all intermediate values of a pager, e.g when a user is dragging, the index\n// value might be anything between 1 -> 2 as they are moving. when a gesture is completed, it figures out\n// the next activeIndex, snaps to it and passes it back. it also handles snapping to different indices when the activeIndex\n// prop changes.\n\n// all styles and positioning of child screens can be computed from this one value, based on a childs index and\n// any style config props passed to the Pager.\n\n// pretty much all other props passed to the Pager are configurations for different behaviours of what is described above\n\nfunction Pager({\n  onChange,\n  initialIndex = 0,\n  children,\n  springConfig,\n  panProps = {},\n  pageSize = 1,\n  threshold = 0.1,\n  minIndex = 0,\n  maxIndex: parentMax,\n  adjacentChildOffset = 10,\n  style,\n  containerStyle,\n  type = 'horizontal',\n  pageInterpolation,\n  clamp = {},\n  clampDrag = {},\n}: iPager) {\n  const { animatedValue, animatedIndex, nextIndex } = useContext(PagerContext);\n\n  const numberOfScreens = Children.count(children);\n\n  const maxIndex =\n    parentMax === undefined\n      ? Math.ceil((numberOfScreens - 1) / pageSize)\n      : parentMax;\n\n  const dragX = memoize(new Value(0));\n  const dragY = memoize(new Value(0));\n  const gestureState = memoize(new Value(0));\n\n  const handleGesture = memoize(\n    event(\n      [\n        {\n          nativeEvent: {\n            translationX: dragX,\n            translationY: dragY,\n          },\n        },\n      ],\n      { useNativeDriver: true }\n    )\n  );\n\n  const handleStateChange = memoize(\n    event(\n      [\n        {\n          nativeEvent: {\n            state: gestureState,\n          },\n        },\n      ],\n      {\n        useNativeDriver: true,\n      }\n    )\n  );\n\n  let initialWidth = UNSET;\n  if (style && style.width) {\n    if (typeof style.width === 'number') {\n      initialWidth = style.width;\n    }\n  }\n\n  let initialHeight = UNSET;\n  if (style && style.height) {\n    if (typeof style.height === 'number') {\n      initialHeight = style.height;\n    }\n  }\n\n  const [width, setWidth] = useState(initialWidth);\n  const [height, setHeight] = useState(initialHeight);\n\n  // assign references based on vertical / horizontal configurations\n  const dimension = memoize(new Value(0));\n  const targetDimension = type === 'vertical' ? 'height' : 'width';\n  const targetTransform = type === 'vertical' ? 'translateY' : 'translateX';\n  const delta = type === 'vertical' ? dragY : dragX;\n\n  const layoutDimension = type === 'vertical' ? height : width;\n\n  // `totalDimension` on the container view is required for android layouts to work properly\n  // otherwise translations move the panHandler off of the screen\n  // set the total width of the container view to the sum width of all the screens\n  const totalDimension = multiply(dimension, numberOfScreens);\n\n  function handleLayout({ nativeEvent: { layout } }: LayoutChangeEvent) {\n    layout.width !== width && setWidth(layout.width);\n    layout.height !== height && setHeight(layout.height);\n  }\n\n  const TYPE = type === 'vertical' ? VERTICAL : HORIZONTAL;\n\n  // props that might change over time should be reactive:\n  const animatedThreshold = useAnimatedValue(threshold);\n  const clampDragPrev = useAnimatedValue(clampDrag.prev, REALLY_BIG_NUMBER);\n  const clampDragNext = useAnimatedValue(clampDrag.next, REALLY_BIG_NUMBER);\n  const animatedMaxIndex = useAnimatedValue(maxIndex);\n  const animatedMinIndex = useAnimatedValue(minIndex);\n\n  // pan event values to track\n  const dragStart = memoize(new Value(0));\n  const swiping = memoize(new Value(FALSE));\n  const _animatedActiveIndex = memoize(new Value(initialIndex));\n  const change = memoize(sub(_animatedActiveIndex, animatedValue));\n  const absChange = memoize(abs(change));\n  const shouldTransition = memoize(greaterThan(absChange, animatedThreshold));\n  const indexChange = memoize(new Value(0));\n\n  // clamp drag values between the configured clamp props\n  // e.g prev => 0.5, next => 0.5 means change can only be between [-0.5, 0.5]\n  // minMax order is reversed because next is negative in translation values\n  const clampedDelta = memoize(\n    min(\n      max(divide(delta, dimension), multiply(clampDragNext, -1)),\n      clampDragPrev\n    )\n  );\n\n  const clock = memoize(new Clock());\n\n  // snap focus to activeIndex when it updates\n  /*\n  useEffect(() => {\n    if (activeIndex >= minIndex && activeIndex <= maxIndex) {\n      nextIndex.setValue(activeIndex);\n    }\n  }, [activeIndex, minIndex, maxIndex]);\n  */\n\n  // animatedIndex represents pager position with an animated value\n  // this value is used to compute the transformations of the container screen\n  // its also used to compute the offsets of child screens, and any other consumers\n  const _animatedValue = memoize(\n    block([\n      cond(\n        eq(gestureState, State.ACTIVE),\n        [\n          cond(clockRunning(clock), stopClock(clock)),\n          // captures the initial drag value on first drag event\n          cond(swiping, 0, [set(dragStart, animatedValue), set(swiping, TRUE)]),\n\n          set(animatedValue, sub(dragStart, clampedDelta)),\n        ],\n        [\n          // on release -- figure out if the index needs to change, and what index it should change to\n          cond(swiping, [\n            set(swiping, FALSE),\n            cond(shouldTransition, [\n              // rounds index change if pan gesture greater than just one screen\n              set(indexChange, ceil(absChange)),\n              // nextIndex set to the next snap point\n              set(\n                nextIndex,\n                cond(\n                  greaterThan(change, 0),\n                  min(\n                    max(\n                      sub(_animatedActiveIndex, indexChange),\n                      animatedMinIndex\n                    ),\n                    animatedMaxIndex\n                  ),\n                  min(\n                    max(\n                      add(_animatedActiveIndex, indexChange),\n                      animatedMinIndex\n                    ),\n                    animatedMaxIndex\n                  )\n                )\n              ),\n              // update w/ value that will be snapped to\n              cond(\n                defined(onChange),\n                call([nextIndex], ([nextIndex]) => onChange?.(nextIndex))\n              ),\n            ]),\n          ]),\n\n          // set animatedActiveIndex for next swipe event\n          set(_animatedActiveIndex, nextIndex),\n          cond(defined(animatedIndex), set(animatedIndex, nextIndex)),\n          set(\n            animatedValue,\n            runSpring(clock, animatedValue, nextIndex, springConfig)\n          ),\n        ]\n      ),\n      debug('position', animatedValue),\n      cond(defined(animatedValue), set(animatedValue, animatedValue)),\n      animatedValue,\n    ])\n  );\n\n  const clampPrevValue = useAnimatedValue(clamp.prev, numberOfScreens);\n  const clampNextValue = useAnimatedValue(clamp.next, numberOfScreens);\n\n  // stop child screens from translating beyond the bounds set by clamp props:\n  const minimum = memoize(\n    multiply(sub(_animatedValue, clampPrevValue), dimension)\n  );\n\n  const maximum = memoize(\n    multiply(add(_animatedValue, clampNextValue), dimension)\n  );\n\n  const animatedPageSize = useAnimatedValue(pageSize);\n\n  // container offset -- this is the window of focus for active screens\n  // it shifts around based on the animatedIndex value\n  const containerTranslation = memoize(\n    multiply(_animatedValue, dimension, animatedPageSize, -1)\n  );\n\n  // slice the children that are rendered by the <Pager />\n  // this enables very large child lists to render efficiently\n  // the downside is that children are unmounted after they pass this threshold\n  // it's an optional prop, however a default value of ~20 is set here to prevent\n  // possible performance bottlenecks to those not aware of the prop or what it does\n\n  // this will slice adjacentChildOffset number of children previous and after\n  // the current active child index into a smaller child array\n  const adjacentChildren =\n    adjacentChildOffset !== undefined\n      ? children.slice(\n          Math.max(initialIndex - adjacentChildOffset, 0),\n          Math.min(initialIndex + adjacentChildOffset + 1, numberOfScreens)\n        )\n      : children;\n\n  // grabbing the height property from the style prop if there is no container style, this reduces\n  // the chances of messing up the layout with containerStyle configurations\n  // can be overridden by the prop itself, but its likely that this is what is intended most of the time\n  // also has the benefit of covering 100% width of container, meaning better pan coverage on android\n  const defaultContainerStyle =\n    style && style.height ? { height: style.height } : undefined;\n\n  function renderChildren() {\n    // waiting for initial layout - except when testing\n    if (width === UNSET) {\n      return null;\n    }\n\n    return adjacentChildren.map((child: any, i) => {\n      // use map instead of React.Children because we want to track\n      // the keys of these children by there index\n      // React.Children shifts these key values intelligently, but it\n      // causes issues with the memoized values in <Page /> components\n      let index = i;\n\n      if (adjacentChildOffset !== undefined) {\n        index =\n          initialIndex <= adjacentChildOffset\n            ? i\n            : initialIndex - adjacentChildOffset + i;\n      }\n\n      return (\n        <Page\n          index={index}\n          animatedIndex={_animatedValue}\n          minimum={minimum}\n          maximum={maximum}\n          dimension={dimension}\n          targetTransform={targetTransform}\n          targetDimension={targetDimension}\n          pageInterpolation={pageInterpolation}\n        >\n          {child}\n        </Page>\n      );\n    });\n  }\n\n  // extra Animated.Views below may seem redundant but they preserve applied styles e.g padding and margin\n  // of the page views\n  return (\n    <Animated.View\n      style={containerStyle || defaultContainerStyle || { flex: 1 }}\n    >\n      <Animated.Code\n        key={layoutDimension}\n        exec={cond(\n          // dimension already set to last layout\n          and(eq(dimension, width), eq(dimension, height)),\n          [],\n          [\n            cond(\n              eq(TYPE, VERTICAL),\n              set(dimension, height),\n              set(dimension, width)\n            ),\n          ]\n        )}\n      />\n\n      <PanGestureHandler\n        {...panProps}\n        onGestureEvent={handleGesture}\n        onHandlerStateChange={handleStateChange}\n      >\n        <Animated.View style={{ flex: 1 }}>\n          <Animated.View style={style || { flex: 1 }}>\n            <Animated.View style={{ flex: 1 }} onLayout={handleLayout}>\n              <Animated.View\n                style={{\n                  flex: 1,\n                  [targetDimension]: totalDimension,\n                  transform: [{ [targetTransform]: containerTranslation }],\n                }}\n              >\n                {renderChildren()}\n              </Animated.View>\n            </Animated.View>\n          </Animated.View>\n        </Animated.View>\n      </PanGestureHandler>\n    </Animated.View>\n  );\n}\n\ninterface iPage {\n  children: React.ReactNode;\n  index: number;\n  minimum: Animated.Node<number>;\n  maximum: Animated.Node<number>;\n  dimension: Animated.Node<number>;\n  targetTransform: 'translateX' | 'translateY';\n  targetDimension: 'width' | 'height';\n  pageInterpolation: iPageInterpolation | undefined;\n  animatedIndex: Animated.Value<number>;\n}\n\nfunction Page({\n  children,\n  index,\n  minimum,\n  maximum,\n  dimension,\n  targetTransform,\n  targetDimension,\n  pageInterpolation,\n  animatedIndex,\n}: iPage) {\n  // compute the absolute position of the page based on index and dimension\n  // this means that it's not relative to any other child, which is good because\n  // it doesn't rely on a mechanism like flex, which requires all children to be present\n  // to properly position pages\n  const position = memoize(multiply(index, dimension));\n\n  // min-max the position based on clamp values\n  // this means the <Page /> will have a container that is always positioned\n  // in the same place, but the inner view can be translated within these bounds\n  const translation = memoize(min(max(position, minimum), maximum));\n\n  const defaultStyle = memoize({\n    // map to height / width value depending on vertical / horizontal configuration\n    // this is crucial to getting child views to properly lay out\n    [targetDimension]: dimension,\n    // min-max the position based on clamp values\n    // this means the <Page /> will have a container that is always positioned\n    // in the same place, but the inner view can be translated within these bounds\n    transform: [\n      {\n        [targetTransform]: translation,\n      },\n    ],\n  });\n\n  // compute the relative offset value to the current animated index so\n  // that <Page /> can use interpolation values that are in sync with drag gestures\n  const offset = memoize(sub(index, animatedIndex));\n\n  // apply interpolation configs to <Page />\n  const interpolatedStyles = memoize(\n    interpolateWithConfig(offset, pageInterpolation)\n  );\n\n  // take out zIndex here as it needs to be applied to siblings\n  let { zIndex, ...otherStyles } = interpolatedStyles;\n\n  // zIndex is not a requirement of interpolation\n  // it will be clear when someone needs it as views will overlap with some configurations\n  if (!zIndex) {\n    zIndex = 0;\n  }\n\n  return (\n    <Animated.View\n      style={{\n        ...StyleSheet.absoluteFillObject,\n        ...defaultStyle,\n        zIndex,\n      }}\n    >\n      <Animated.View style={[StyleSheet.absoluteFillObject, otherStyles]}>\n        {children}\n      </Animated.View>\n    </Animated.View>\n  );\n}\n\n// utility to update animated values without changing their reference\n// this is key for using memoized Animated.Values and prevents costly rerenders\nfunction useAnimatedValue(\n  value?: number,\n  defaultValue = 0\n): Animated.Value<number> {\n  const initialValue = value !== undefined ? value : defaultValue;\n  const animatedValue = memoize(new Value(initialValue));\n\n  useEffect(() => {\n    if (value !== undefined) {\n      animatedValue.setValue(value);\n    }\n  }, [value]);\n\n  return animatedValue;\n}\n\ninterface iPagerContext {\n  animatedValue: Animated.Value<number>;\n  animatedIndex: Animated.Value<number>;\n  nextIndex: Animated.Value<number>;\n}\n\nconst PagerContext = createContext<iPagerContext>({\n  animatedValue: new Value(0),\n  animatedIndex: new Value(0),\n  nextIndex: new Value(0),\n});\n\ninterface iPagerProvider {\n  children: React.ReactNode;\n  initialIndex: number;\n}\n\nconst PagerProvider: React.FC<iPagerProvider> = ({\n  children,\n  initialIndex = 0,\n}) => {\n  const animatedValue = memoize(new Value<number>(initialIndex));\n  const animatedIndex = memoize(new Value<number>(initialIndex));\n  const nextIndex = memoize(new Value<number>(initialIndex));\n\n  return (\n    <PagerContext.Provider value={{ animatedValue, animatedIndex, nextIndex }}>\n      {typeof children === 'function'\n        ? children({ animatedValue, animatedIndex, nextIndex })\n        : children}\n    </PagerContext.Provider>\n  );\n};\n\nfunction usePager(): iPagerContext {\n  const context = useContext(PagerContext);\n\n  if (context === undefined) {\n    throw new Error(`usePager() must be used within a <PagerProvider />`);\n  }\n\n  return context;\n}\n\nconst IndexContext = React.createContext<undefined | number>(undefined);\n\ninterface iIndexProvider {\n  children: React.ReactNode;\n  index: number;\n}\n\nfunction useIndex() {\n  const index = useContext(IndexContext);\n\n  if (index === undefined) {\n    throw new Error(`useIndex() must be used within an <IndexProvider />`);\n  }\n\n  return index;\n}\n\nfunction useAnimatedIndex() {\n  const pager = usePager();\n  return pager[2];\n}\n\nfunction useOffset(index: number) {\n  const animatedIndex = useAnimatedIndex();\n  const offset = memoize(sub(index, animatedIndex));\n\n  return offset;\n}\n\nfunction useInterpolation(\n  pageInterpolation: iPageInterpolation,\n  index?: number\n) {\n  const _index = index !== undefined ? index : useIndex();\n  const offset = useOffset(_index);\n  const styles = memoize(interpolateWithConfig(offset, pageInterpolation));\n  return styles;\n}\n\nfunction interpolateWithConfig(\n  offset: Animated.Node<number>,\n  pageInterpolation?: iPageInterpolation\n): ViewStyle {\n  if (!pageInterpolation) {\n    return {};\n  }\n\n  return Object.keys(pageInterpolation).reduce((styles: any, key: any) => {\n    const currentStyle = pageInterpolation[key];\n\n    if (Array.isArray(currentStyle)) {\n      const _style = currentStyle.map((interpolationConfig: any) =>\n        interpolateWithConfig(offset, interpolationConfig)\n      );\n\n      styles[key] = _style;\n      return styles;\n    }\n\n    if (typeof currentStyle === 'object') {\n      let _style;\n      const { unit, ...rest } = currentStyle;\n      if (currentStyle.unit) {\n        _style = concat(interpolate(offset, rest), currentStyle.unit);\n      } else {\n        _style = interpolate(offset, currentStyle);\n      }\n\n      styles[key] = _style;\n      return styles;\n    }\n\n    if (typeof currentStyle === 'function') {\n      const _style = currentStyle(offset);\n      styles[key] = _style;\n      return styles;\n    }\n\n    return styles;\n  }, {});\n}\n\nfunction memoize(value: any): any {\n  const ref = React.useRef(value);\n  return ref.current;\n}\n\nconst DEFAULT_SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: false,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n};\n\nfunction runSpring(\n  clock: Animated.Clock,\n  position: Animated.Value<number>,\n  toValue: Animated.Node<number>,\n  springConfig?: Partial<SpringConfig>\n) {\n  const state = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: position,\n    time: new Value(0),\n  };\n\n  const config = {\n    ...DEFAULT_SPRING_CONFIG,\n    ...springConfig,\n    toValue: new Value(0),\n  };\n\n  return block([\n    cond(\n      clockRunning(clock),\n      [\n        cond(neq(config.toValue, toValue), [\n          set(state.finished, 0),\n          set(config.toValue, toValue),\n        ]),\n      ],\n      [\n        set(state.finished, 0),\n        set(state.time, 0),\n        set(state.velocity, 0),\n        set(config.toValue, toValue),\n        startClock(clock),\n      ]\n    ),\n    spring(clock, state, config),\n    cond(state.finished, [stopClock(clock), set(state.position, position)]),\n    state.position,\n  ]);\n}\n\nexport {\n  Pager,\n  PagerProvider,\n  PagerContext,\n  usePager,\n  useOffset,\n  useIndex,\n  useAnimatedIndex,\n  useInterpolation,\n};\n","import { useRef } from 'react';\nimport { ViewStyle } from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport { iPageInterpolation, SpringConfig } from './pager';\n\nconst {\n  interpolate,\n  concat,\n  Value,\n  clockRunning,\n  cond,\n  neq,\n  set,\n  startClock,\n  spring,\n  stopClock,\n  block,\n} = Animated;\n\nfunction interpolateWithConfig(\n  offset: Animated.Node<number>,\n  pageInterpolation?: iPageInterpolation\n): ViewStyle {\n  if (!pageInterpolation) {\n    return {};\n  }\n\n  return Object.keys(pageInterpolation).reduce((styles: any, key: any) => {\n    const currentStyle = pageInterpolation[key];\n\n    if (Array.isArray(currentStyle)) {\n      const _style = currentStyle.map((interpolationConfig: any) =>\n        interpolateWithConfig(offset, interpolationConfig)\n      );\n\n      styles[key] = _style;\n      return styles;\n    }\n\n    if (typeof currentStyle === 'object') {\n      let _style;\n      const { unit, ...rest } = currentStyle;\n      if (currentStyle.unit) {\n        _style = concat(interpolate(offset, rest), currentStyle.unit);\n      } else {\n        _style = interpolate(offset, currentStyle);\n      }\n\n      styles[key] = _style;\n      return styles;\n    }\n\n    if (typeof currentStyle === 'function') {\n      const _style = currentStyle(offset);\n      styles[key] = _style;\n      return styles;\n    }\n\n    return styles;\n  }, {});\n}\n\nfunction memoize(value: any): any {\n  const ref = useRef(value);\n  return ref.current;\n}\n\nconst DEFAULT_SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: false,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n};\n\nfunction runSpring(\n  clock: Animated.Clock,\n  position: Animated.Value<number>,\n  toValue: Animated.Node<number>,\n  springConfig?: Partial<SpringConfig>\n) {\n  const state = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: position,\n    time: new Value(0),\n  };\n\n  const config = {\n    ...DEFAULT_SPRING_CONFIG,\n    ...springConfig,\n    toValue: new Value(0),\n  };\n\n  return block([\n    cond(\n      clockRunning(clock),\n      [\n        cond(neq(config.toValue, toValue), [\n          set(state.finished, 0),\n          set(config.toValue, toValue),\n        ]),\n      ],\n      [\n        set(state.finished, 0),\n        set(state.time, 0),\n        set(state.velocity, 0),\n        set(config.toValue, toValue),\n        startClock(clock),\n      ]\n    ),\n    spring(clock, state, config),\n    cond(state.finished, [stopClock(clock), set(state.position, position)]),\n    state.position,\n  ]);\n}\n\nexport { interpolateWithConfig, memoize, runSpring };\n","import React, { Children } from 'react';\nimport Animated from 'react-native-reanimated';\nimport { ViewStyle, LayoutChangeEvent } from 'react-native';\nimport { iPageInterpolation, useOffset, useAnimatedIndex } from './pager';\nimport { memoize, interpolateWithConfig } from './util';\n\nconst { Value, divide, multiply, add } = Animated;\n\ninterface iPagination {\n  children: React.ReactNode;\n  pageInterpolation: iPageInterpolation;\n  style?: ViewStyle;\n}\n\nconst DEFAULT_PAGINATION_STYLE: ViewStyle = {\n  height: 50,\n  width: '100%',\n  flexDirection: 'row',\n};\n\nfunction Pagination({ children, pageInterpolation, style }: iPagination) {\n  return (\n    <Animated.View\n      style={{\n        ...DEFAULT_PAGINATION_STYLE,\n        ...style,\n      }}\n    >\n      {Children.map(children, (child: any, index) => (\n        <PaginationItem\n          index={index}\n          pageInterpolation={pageInterpolation}\n          style={child.props.style}\n        >\n          {child}\n        </PaginationItem>\n      ))}\n    </Animated.View>\n  );\n}\n\ninterface iPaginationItem {\n  children: React.ReactNode;\n  pageInterpolation: iPageInterpolation;\n  index: number;\n  style?: ViewStyle;\n}\n\nfunction PaginationItem({\n  children,\n  pageInterpolation,\n  index,\n  style,\n}: iPaginationItem) {\n  const offset = useOffset(index);\n  const configStyles = memoize(\n    interpolateWithConfig(offset, pageInterpolation)\n  );\n\n  return (\n    <Animated.View style={[style || { flex: 1 }, configStyles]}>\n      {children}\n    </Animated.View>\n  );\n}\n\ninterface iSlider {\n  numberOfScreens: number;\n  style: ViewStyle;\n}\n\nconst DEFAULT_SLIDER_STYLE = {\n  height: 2,\n  backgroundColor: 'aquamarine',\n};\n\nfunction Slider({ numberOfScreens, style }: iSlider) {\n  const animatedIndex = useAnimatedIndex();\n  const width = memoize(new Value(0));\n\n  function handleLayout({ nativeEvent: { layout } }: LayoutChangeEvent) {\n    width.setValue(layout.width as any);\n  }\n\n  const sliderWidth = divide(width, numberOfScreens);\n  const translation = memoize(multiply(animatedIndex, sliderWidth));\n\n  return (\n    <Animated.View onLayout={handleLayout}>\n      <Animated.View\n        style={{\n          width: sliderWidth,\n          transform: [{ translateX: translation }],\n          ...DEFAULT_SLIDER_STYLE,\n          ...style,\n        }}\n      />\n    </Animated.View>\n  );\n}\n\nfunction Progress({ numberOfScreens, style }: iSlider) {\n  const animatedIndex = useAnimatedIndex();\n\n  const width = memoize(new Value(0));\n\n  function handleLayout({ nativeEvent: { layout } }: LayoutChangeEvent) {\n    width.setValue(layout.width as any);\n  }\n\n  const sliderWidth = memoize(\n    divide(width, numberOfScreens, divide(1, add(animatedIndex, 1)))\n  );\n\n  return (\n    <Animated.View onLayout={handleLayout}>\n      <Animated.View\n        style={{\n          width: sliderWidth,\n          height: 2,\n          backgroundColor: 'rebeccapurple',\n          ...DEFAULT_SLIDER_STYLE,\n          ...style,\n        }}\n      />\n    </Animated.View>\n  );\n}\n\nexport { Pagination, Slider, Progress };\n"],"names":["Extrapolate","event","Animated","defined","block","Value","divide","cond","eq","add","stopClock","Clock","set","clockRunning","multiply","sub","call","max","min","greaterThan","abs","ceil","interpolate","concat","neq","and","startClock","spring","debug","Page","children","index","minimum","maximum","dimension","targetTransform","targetDimension","pageInterpolation","animatedIndex","position","memoize","translation","defaultStyle","transform","offset","interpolatedStyles","interpolateWithConfig","zIndex","otherStyles","React","View","style","StyleSheet","absoluteFillObject","useAnimatedValue","value","defaultValue","animatedValue","undefined","useEffect","setValue","PagerContext","createContext","nextIndex","usePager","context","useContext","Error","IndexContext","useIndex","useAnimatedIndex","useOffset","Object","keys","reduce","styles","key","currentStyle","Array","isArray","_style","map","interpolationConfig","rest","unit","useRef","current","DEFAULT_SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","runSpring","clock","toValue","springConfig","state","finished","velocity","time","config","DEFAULT_PAGINATION_STYLE","height","width","flexDirection","PaginationItem","configStyles","flex","DEFAULT_SLIDER_STYLE","backgroundColor","onChange","initialIndex","panProps","pageSize","threshold","minIndex","parentMax","maxIndex","adjacentChildOffset","containerStyle","type","clamp","clampDrag","numberOfScreens","Children","count","Math","dragX","dragY","gestureState","handleGesture","nativeEvent","translationX","translationY","useNativeDriver","handleStateChange","initialWidth","initialHeight","useState","setWidth","setHeight","delta","layoutDimension","totalDimension","TYPE","animatedThreshold","clampDragPrev","prev","clampDragNext","next","animatedMaxIndex","animatedMinIndex","dragStart","swiping","_animatedActiveIndex","change","absChange","shouldTransition","indexChange","clampedDelta","_animatedValue","State","ACTIVE","clampPrevValue","clampNextValue","animatedPageSize","containerTranslation","adjacentChildren","slice","Code","exec","PanGestureHandler","onGestureEvent","onHandlerStateChange","onLayout","layout","child","i","Provider","props","sliderWidth","translateX"],"mappings":"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"}